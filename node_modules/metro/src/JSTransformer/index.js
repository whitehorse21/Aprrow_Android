/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var _require =

require('metro-core');const Logger = _require.Logger;

const debug = require('debug')('Metro:JStransformer');
const Worker = require('jest-worker').default;


















module.exports = class Transformer {



  constructor(
  transformModulePath,
  maxWorkers,
  reporters)

  {let workerPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : require.resolve('./worker');
    this._transformModulePath = transformModulePath;

    if (maxWorkers > 1) {
      this._worker = this._makeFarm(
      workerPath,
      ['minify', 'transform'],
      maxWorkers);


      this._worker.getStdout().on('data', chunk => {
        reporters.stdoutChunk(chunk.toString('utf8'));
      });

      this._worker.getStderr().on('data', chunk => {
        reporters.stderrChunk(chunk.toString('utf8'));
      });
    } else {
      this._worker = require(workerPath);
    }
  }

  kill() {
    if (this._worker && typeof this._worker.end === 'function') {
      this._worker.end();
    }
  }

  minify(
  filename,
  code,
  sourceMap)
  {var _this = this;return _asyncToGenerator(function* () {
      return yield _this._worker.minify(filename, code, sourceMap);})();
  }

  transformFile(
  filename,
  localPath,
  code,
  isScript,
  options,
  assetExts,
  assetRegistryPath)
  {var _this2 = this;return _asyncToGenerator(function* () {
      try {
        debug('Started ransforming file', filename);

        const data = yield _this2._worker.transform(
        _this2._transformModulePath,
        filename,
        localPath,
        code,
        isScript,
        options,
        assetExts,
        assetRegistryPath);


        debug('Done transforming file', filename);

        Logger.log(data.transformFileStartLogEntry);
        Logger.log(data.transformFileEndLogEntry);

        return data.result;
      } catch (err) {
        debug('Failed transformFile file', filename);

        if (err.loc) {
          throw _this2._formatBabelError(err, filename);
        } else {
          throw _this2._formatGenericError(err, filename);
        }
      }})();
  }

  _makeFarm(workerPath, exposedMethods, maxWorkers) {
    // We whitelist only what would work. For example `--inspect` doesn't work
    // in the workers because it tries to open the same debugging port. Feel
    // free to add more cases to the RegExp. A whitelist is preferred, to
    // guarantee robustness when upgrading node, etc.
    const execArgv = process.execArgv.filter(
    arg =>
    /^--stack[_-]trace[_-]limit=[0-9]+$/.test(arg) ||
    /^--heap[_-]growing[_-]percent=[0-9]+$/.test(arg) ||
    /^--max[_-]old[_-]space[_-]size=[0-9]+$/.test(arg));


    return new Worker(workerPath, {
      exposedMethods,
      forkOptions: { execArgv },
      maxWorkers });

  }

  _formatGenericError(err, filename) {
    const error = new TransformError(`${filename}: ${err.message}`);

    return Object.assign(error, {
      stack: (err.stack || '').
      split('\n').
      slice(0, -1).
      join('\n'),
      lineNumber: 0 });

  }

  _formatBabelError(err, filename) {
    const error = new TransformError(
    `${err.type || 'Error'} in ${filename}: ${err.message}`);


    // $FlowFixMe: extending an error.
    return Object.assign(error, {
      stack: err.stack,
      snippet: err.codeFrame,
      lineNumber: err.loc.line,
      column: err.loc.column,
      filename });

  }};


class TransformError extends SyntaxError {


  constructor(message) {
    super(message);this.type = 'TransformError';
    Error.captureStackTrace && Error.captureStackTrace(this, TransformError);
  }}